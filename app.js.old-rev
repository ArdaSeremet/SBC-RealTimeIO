#!/usr/bin/env node

var express = require('express');
var http = require('http');
var path = require('path');
var app = module.exports.app = express();
var server = http.createServer(app);
var io = require('socket.io')(server);
var fs = require('fs');
var { exec, execSync } = require('child_process');
var ioData;
var outputs = [];
var inputs = [];
var os = require('os');
const available_pins = ['11','12','68','15','16','17','55','54','56','65','64','69','74','73','71','57','76','72','77','78','79','80','75','70'];
var project_folder;
var validationToken = fs.readFileSync(path.join(__dirname, './security.txt')).toString().replace('\n', '');
if(process.pkg){
    project_folder = path.dirname(process.execPath);
}else{
    project_folder = __dirname;
}

/* SOFTWARE PERM VALIDATION  */
function control_mac() {
        if(os.networkInterfaces().eth0[0].mac.slice(os.networkInterfaces().eth0[0].mac.length - 5).toString() != validationToken.toString()) {
                console.error('This software is a property of Progettihwsw Sas  and can only be used on permitted machines! Aborting process...');
                http.get('http://www.progettihwsw.com/unpermitted_usage/' + os.networkInterfaces().eth0[0].mac);
                process.exit(1);
        }
}
control_mac();
setInterval(control_mac, 10000);
app.get('/getconf', (req, res) => {
        res.end(fs.readFileSync('./conf.json'));
});
app.get('/reboot', (req, res) => {
        if(!req.headers.authorization || req.headers.authorization.indexOf('Basic ') === -1) {
                res.statusCode = 401;
                res.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"');
                res.end('Authorization is required!');
                return false;
        }
        const base64Credentials = req.headers.authorization.split(' ')[1];
        const credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');
        const [username, password] = credentials.split(':');
        if(username != 'admin' || password != 'password') {
                res.statusCode = 401;
                res.write('Invalid Authentication Credentials!');
                return false;
        }
        try {
                res.send('The request has been sent to the server!');
                execSync('systemctl reboot');
        } catch(e) {
                res.send('An error occured while processing your request. Try again later.');
        }
});
app.get('/static-ip', (req, res) => {
	res.sendFile(path.join(__dirname, 'static/static-ip.html'));
});
app.get('/static-ip/get', (req, res) => {
	res.writeHead(200, { 'Content-Type': 'text/json' });
        res.write('{ "ip-address": "' + os.networkInterfaces().eth0[0].address + '", "gateway-ip-address": "' +  execSync("ip r | grep eth0 | grep default | cut -d ' ' -f 3 | head -n1").toString().replace('\n', '') + '" }');
	res.end();
});
app.get('/static-ip/set', (req, res) => {
	if(!req.headers.authorization || req.headers.authorization.indexOf('Basic ') === -1) {
		res.statusCode = 401;
		res.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"');
		res.end('Authorization is required!');
		return false;
	}
	const base64Credentials = req.headers.authorization.split(' ')[1];
	const credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');
	const [username, password] = credentials.split(':');
	if(username != 'admin' || password != 'password') {
		res.statusCode = 401;
		res.write('Invalid Authentication Credentials!');
		return false;
	}
	try {
		execSync(`nmcli connection modify 'Wired connection 1' connection.autoconnect yes ipv4.method ${(req.query.dhcp == 'true') ? 'auto' : 'manual'} ipv4.address ${req.query['ip-address']}/24 ipv4.gateway ${req.query['gateway-ip-address']} ipv4.dns 8.8.8.8,8.8.4.4`);
		res.write('IP address has been succesfully set. Please reboot the board to apply the changes.');
		res.end();
	} catch(e) {
		res.write('An error occured while processing your request. Try again later.');
		res.end();
	}
});
app.get('/set/:pin/:state', (req, res) => {
        let pin = req.params.pin.toString();
        let state = req.params.state.toString();
        if(available_pins.includes(pin) && pin in ioData.controllable_pins && ioData.controllable_pins[pin] == '1' && (state == 'on' || state == 'off')) {
                let stateNum = state == 'on' ? '1' : '0';
                exec('bash sys/' + state + '.sh ' + pin, (err, stdout, stderr) => {
                        if(err) { console.error(err); res.end('fail'); return; }
                        if(stderr) { console.error(stderr); res.end('fail'); return; }
                        ioData.pinStates[pin] = stateNum;
                        emitAllClients('stateHasChanged', {'pin': pin, 'state': stateNum});
                        res.end('success');
                });
        } else {
                res.end('Invalid request');
        }
});

app.get('/add/:pin/:dir', (req, res) => {
        let pin = req.params.pin.toString();
        let dir = req.params.dir.toString();
        if(available_pins.includes(pin) && !(pin in ioData.controllable_pins) && (dir == 'as output' || dir == 'as input')) {
                dir = dir == 'as output' ? 'output' : 'input';
                exec('bash sys/' + (dir == 'output' ? 'out' : 'in') + '.sh ' + pin, (err, stdout, stderr) => {
                        if(err) { console.error(err); res.end('fail'); return; }
                        if(stderr) { console.error(err); res.end('fail'); return; }
                        ioData.controllable_pins[pin] = dir == 'output' ? '1' : '0';
                        ioData.pinNames[pin] = (dir == 'output' ? 'Relay #' : 'Input #') + pin;
                        ioData.pinStates[pin] = 'unknown';
                        emitAllClients('pinHasAdded', {'pin': pin, 'direction': ioData.controllable_pins[pin], 'name': ioData.pinNames[pin]});
                        console.log('Pin : ' + pin + ' | Mode: ' + stdout.toString());
                        res.end('Pin number ' + pin + ' is added as ' + dir);
                });
        }else{
                res.end('Invalid request');
                console.log('Pin: ' + pin + ' | Direction: ' + dir);
        }
});

app.use(express.static(path.join(__dirname, 'static')));

app.get('/', (req, res) => {
	res.sendFile(path.join(__dirname, 'static/index.html'));
});

function initData() {
	let data = fs.readFileSync(path.join(project_folder, 'conf.json'));
	ioData = JSON.parse(data);
	if(!ioData.boardName) {
		ioData.boardName = Math.random().toString(36).slice(2);
	}
	for(let [key, value] of Object.entries(ioData.controllable_pins)) {
		if(!available_pins.includes(key)) {
			console.log("Pin number " + key + " is not valid! Removing it from JSON.");
			delete ioData.controllable_pins[key];
			continue;
		}
		if(!ioData.pinOrder.includes(key)) {
			ioData.pinOrder.push(key);
		}
		if(fs.existsSync("/sys/class/gpio/gpio" + key + "/value")) { execSync('bash sys/unexport.sh ' + key);  }
		//if(value == '1' || value == '0') { execSync('bash sys/export.sh ' + key, err => { console.error('Bash export err: ' + err);}); }
		if(value == '1') {
			if(!(key in ioData.pinNames)) { ioData.pinNames[key] = 'Relay ' + key; }
			outputs.push(key);
			execSync('bash sys/out.sh ' + key.toString(), (err, stdout, stderr) => {
				if(err) { console.error('GPIO Mode Setting Error(init): ' + err); return; }
				if(stderr) { console.error('GPIO Mode Setting StdError(init): ' + stderr); return; }
			});
		}
		if(value == '0') {
			if(!(key in ioData.pinNames)) { ioData.pinNames[key] = 'Input ' + key;}
			inputs.push(key);
			execSync('bash sys/in.sh ' + key.toString(), (err, stdout, stderr) => {
				if(err) { console.error('GPIO Mode Setting Error(init): ' + err); return; }
				if(stderr) { console.error('GPIO Mode Setting StdError(init): ' + stderr); return; }
			});
		}
		exec('bash sys/read.sh ' + key, (err, stdout, stderr) => {
			if(err) { console.error(err); return; }
			if(stderr) { console.error(stderr); return; }
			let out = stdout.toString().replace("\n", "");
			ioData.pinStates[key] = out;
		});
	}
	saveData();
}
function saveData() {
	let jsonData = JSON.stringify(ioData, null, "\t");
	try {
		JSON.parse(jsonData);
	} catch(e) {
		console.log('JSON Validation Error! Data: ' + jsonData);
		return false;
	}
	if(!jsonData || jsonData === undefined || jsonData == null) { console.log('Trying to save an empty JSON string.'); return false; }
	fs.writeFileSync(path.join(project_folder, 'conf.json'), jsonData, err => {
		if(err) { console.error(err); }
	});
	return true;
}
function emitAllClients(event, msg) {
	sessions.forEach((item, i) => {
		io.to(item).emit(event, msg);
	});
}
function checkPins() {
	for(let [key, val] of Object.entries(ioData.controllable_pins)) {
		exec('bash sys/read.sh ' + key.toString(), (err, stdout, stderr) => {
			if(err) { console.error(err); return; }
			if(stderr) { console.error(stderr); return; }
			if(ioData.pinStates[key] != stdout.toString().replace('\n', '')) {
				ioData.pinStates[key] = stdout.toString().replace('\n', '');
				emitAllClients('stateHasChanged', {'pin': key, 'state': stdout.replace('\n', '').toString()});
			}
		});
	}
	saveData();
}
initData();

app.get('/status', (req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.write("<style>body{display: flex;flex-direction: column;align-items: center;font-family: 'Arial', sans-serif;}table{ border-collapse: collapse; }td,th {border: 1px solid #ebebeb;padding: 5px 10px;text-align: center}tbody tr:nth-child(odd){background-color: #F4F4F4 }</style>");
	res.write("<table><thead><tr><th>GPIO Number</th><th>Name</th><th>Direction</th><th>Value</th></tr></thead><tbody>");
        ioData.pinOrder.forEach((item, i) => {
                res.write("<tr><td>" + item + "</td><td>" + ioData.pinNames[item] + "</td><td>" + (ioData.controllable_pins[item] == '1' ? 'Output' : 'Input') + "</td><td>" + (ioData.pinStates[item] == '1' ? 'ON' : 'OFF') + "</td></tr>");
        });
        res.write('</tbody></table>');
        res.end();
});
app.get('/data', (req, res) => {
        res.type('application/xml');
        res.write('<?xml version="1.0" ?><Root BoardName="'+ ioData.boardName +'"><Pins>');
        ioData.pinOrder.forEach((item, i) => {
                if(item in ioData.controllable_pins) {
                        res.write('<Pin><Name>'+ ioData.pinNames[item] +'</Name><Direction>'+ ((ioData.controllable_pins[item] == '1') ? 'Output': 'Input') +'</Direction><Value>'+ ((ioData.pinStates[item] == '1') ? 'ON' : 'OFF') +'</Value></Pin>');
                }
        });
        res.write('</Pins></Root>');
        res.end();
});
function windowsblueStatusUpdater() {
        var queryString = ioData.boardName.replace(/s+/g, '') + '_';
        ioData.pinOrder.forEach((item, i) => {
                if(item.toString() in ioData.controllable_pins) {
                        let name = ioData.pinNames[item.toString()];
                        let nameSpaceless = name.replace(/\s+/g, '');
                        let valueStr = (ioData.pinStates[item] == '1') ? 'ON' : 'OFF';
                        queryString += nameSpaceless + 'is' + valueStr + '_';
                }
        });
        queryString = queryString.slice(0, -1);
        http.get(`http://windowsblue.it/boards.php?in=${queryString}`);
}

/* Socket */
var sessions = [];
setInterval(checkPins, 4000);
setInterval(windowsblueStatusUpdater, 60000);
io.on('connection', (socket) => {
	sessions.push(socket.id);
	socket.on('ioRequest', () => {
		socket.emit('gpioData', ioData);
	});
	socket.on('stateChangeRequest', (data) => {
		let pin = data.pin.toString();
		let state = data.state.toString();
		if(available_pins.includes(pin) && pin in ioData.controllable_pins && (state == '1' || state == '0')) {
			let stateStr = state == '1' ? 'on' : 'off';
			exec('bash sys/' + stateStr + '.sh ' + pin, (err, stdout, stderr) => {
				if(err) { console.error('GPIO Writing Error(changeRequest): ' + err); return; }
				if(stderr) { console.error('GPIO Writing StdError(changeRequest): ' + stderr); return; }
				ioData.pinStates[pin] = state;
				emitAllClients('stateHasChanged', data);
			});
		} else {
			console.log('stateChangeRequest Input Validation Error!');
		}
	});
	socket.on('newPinRequest', (data) => {
		let pin = data.pin;
		let dir = data.direction;
		if(available_pins.includes(pin) && (dir == '1' || dir == '0') && !(pin in ioData.controllable_pins)) {
			let dirStr = dir == '1' ? 'out': 'in';
			let name = dir == '1' ? 'Relay #' + pin : 'Input #' + pin;
			if(fs.existsSync("/sys/class/gpio/gpio" + pin + "/value")) { execSync('bash sys/unexport.sh ' + pin);  }
			exec('bash sys/' + dirStr + '.sh ' + pin, (err, stdout, stderr) => {
				if(err) { console.error('GPIO Mode Setting Error: ' + err); return; }
				if(stderr) { console.error('GPIO Mode Setting  StdError: ' + stderr); return; }
				ioData.controllable_pins[pin] = dir;
				ioData.pinNames[pin] = name;
				ioData.pinStates[pin] = 'unknown';
				emitAllClients('pinHasAdded', {'pin': pin, 'direction': dir, 'name': name});
			});
		}else{
			console.log('Added pin is not valid or direction is not set! Removing it(' + pin + ').');
			return false;
		}
	});
	socket.on('removePinRequest', (data) => {
		let pin = data.pin;
		if(pin in ioData.controllable_pins) {
			delete ioData.controllable_pins[pin];
			delete ioData.pinStates[pin];
			delete ioData.pinNames[pin];
			if(fs.existsSync("/sys/class/gpio/gpio" + pin + "/value")) { execSync('bash sys/unexport.sh ' + pin); }
			emitAllClients('pinHasRemoved', {'pin': pin});
		}else{
			console.log('Pin to be removed is not in the object(' + pin + ').');
			return false;
		}
	});
	socket.on('renamePinRequest', (data) => {
		let pin = data.pin;
		let name = data.name;
		if(pin in ioData.controllable_pins && (name != '' || name)) {
			ioData.pinNames[pin] = name;
			emitAllClients('pinHasRenamed', {'pin': pin, 'name': name});
		}else{
			console.log('Pin to be renamed is not in the object(' + pin + ').');
			return false;
		}
	});
	socket.on('renameBoardRequest', (data) => {
		let name = data.name;
		if(name.length > 0 && (name != '' || name)) {
			ioData.boardName = name;
			emitAllClients('boardHasRenamed', {'name': name});
		}else{
			console.log('Board cannot be renamed. Check input(' + pin + ').');
			return false;
		}
	});

	socket.on('disconnect', () => {
		console.log('Socket is disconnected with ID: ' + socket.id);
		delete sessions[socket.id];
	})
});



server.listen(80);
